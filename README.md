# Лабораторная работа №1 по курсу «Теория формальных языков»


### Постановка задачи
По имеющейся SRS определить:
* завершимость

* конечность классов эквивалентности по НФ (для построения эквивалент-ностей считаем, что правила могут применяться в обе стороны). Если их конечное число, то построить минимальную систему переписывания, им соответствующую.

* локальную конфлюэнтность и дополняемость по Кнуту-Бендиксу

Все проверки выше можно делать вручную. Для их фиксации желательно использовать формат та со встроенными latex-формулами, поддерживаемыми MathJax, либо формат ва обсидиана (он допускает расширенную поддержку latex в формулах). Можно и чистый latex. Допустимо сдавать и фото на листочках, но за оформление в Markdown/Latex добавляется 1 балл. Ачивка перманентная, в других лабораторных она тоже будет.

По SRS T тем самым (исключая случай, когда она сразу локально конфлюэнтна или конечна и минимальна) строится другая SRS T', которая должна сохранять те же классы эквивалентности. Если исходная SRS завершима, то правила в T' должны удовлетворять условию убывания левой части относительно правой по выбранному вами фундированному порядку

Провести автоматическое тестирование предполагаемой эквивалентности двух указанных SRS

Фазз-тестирование эквивалентности: строится случайное слово w и случайная цепочка переписываний его в w' по Т. Проверить, можно ли получить w' из w (или наоборот) в рамках правил T'.

Метаморфное тестирование: выбрать инварианты, которые должны сохраняться (либо монотонно изменяться) при переписывании в рамках T. Породить случайную цепочку переписываний над случайным словом в T' и проверить выполнимость инвариантов. Как минимум два разных инварианта. Если инвариантов найдено больше и они нетривиальные (неформально — нельзя увидеть их по SRS за пять минут внимательного рассматривания), за них можно получить до 2 дополнительных баллов.


### Индивидуальный вариант №14
1) $ac \to c$ 

2) $aa \to ba$

3) $bc \to c$

4) $ca \to aa$

5) $cb \to bc$

6) $ccc \to c$

7) $aaa \to aa$

8) $aab \to ba$

9) $abb \to aba$

10) $bbb \to bba$

***


### 1. Доказательство завершимости
У нас есть алфавит {a, b, c} и 10 правил вида u → v, где u и v — строки.
SRS завершима (terminating), если не существует бесконечной последовательности переписываний, т.е. любой процесс рано или поздно останавливается.

Сначала проверим, всегда ли длина строки уменьшается.

Длина уменьшается в правилах:

1) ac → c (2 → 1)

3) bc → c (2 → 1)

6) ccc → c (3 → 1)

7) aaa → aa (3 → 2)

8) aab → ba (3 → 2)

Длина сохраняется в правилах:

2) aa → ba (2 → 2)

4) ca → aa (2 → 2)

5) cb → bc (2 → 2)

9) abb → aba (3 → 3) 

10) bbb → bba (3 → 3)

Правил, где длина увеличивается, нету.

Теперь пройдемся более подробно по каждому правилу. 

#### Шаг 1. 

Рассмотрим правила 1) ac → c и 3) bc → c .

Из этих двух правил следует, что если перед буквой $\{c}$ встретились буква $\{a}$ или $\{b}$ , то они пропадут , а $\{c}$ останется в неизменном виде. Длинна слова уменьшается. Поэтому оба этих правила приведут к конечному результату. 

$size(t)$ > $size(t')$  (2>1)


#### Шаг 2.
Рассмотрим правила 3) bc → c и 5) cb → bc .

Правило 5) дополняет правило 3) и сново сводит его к результату $\{c}$.

$w_1$ bc $w_2$ -> $w_1$ c $w_2$

$w_1$ cb $w_2$ -> $w_1$ bc $w_2$-> $w_1$ c $w_2$


#### Шаг 3.

Рассмотрим правило 6) ccc → c.

$size(t)_c$ > $size(t')_c$  (3>1)

При получении длинной последовательности состоящей из $\{c}$, можем сократить их количество в 2/3 раза и сводит результат к $\{c}$.



#### Шаг 4.
Рассмотрим правила 1) ac → c и 4) ca → aa.

Какую бы пару не встретили всегда есть для нее правило, которое в любом случае избавляет от одной буквы ( не в значении кол-ва ).

Рассмотрим пример (построить нормальные деревья потом)




Из примера можно сделать вывод:

а) если перед $\{c}$ есть $\{a}$, то рано или поздно придем к последовательности состоящий из $\{c}$ ( в кол-ве от 1 до N штук). 

b) Если $\{a}$ стоит после $\{c}$, то все $\{c}$ превращаются в $\{a}$.



#### Шаг 5.

Рассмотрим правило 7) aaa → aa в дополнение к прошлому шагу. 

Оно уменьшает кол-во $\{a}$ и поэтому ускоряет процесс уменьшения слова. (подходит для пункта b) из шага 4)

$size(t)_a$ > $size(t')_a$  (3>2)



#### Шаг 6.

Рассмотрим оставшиеся правила, а именно:
2) aa → ba 

8) aab → ba

9) abb → aba  

10) bbb → bba 

Первые да правила сводятся к одному результату.

Вторые два правила дают разный результат, но у обоих результат зависит от первой буквы. 

Можно заметить, что у нас нет правила содержащего буквы $\{a}$ и $\{b}$, где $\{b}$ была бы первой. Здесь можно зделать пометку, что если мы дойдем до такой комбинации, то она будет конечна (не для всех случаев. Только если длина слова меньше или ровна 3)


Если рассматривать длинные слова, то к сожалению, нашлось как минимум два слова, применяя правила к которым, мы получили цикл.

[Примеры с циклом](C:/Users/anyal/PycharmProjects/FormalLanguageTheory/Lab1/image_tree/tree_cucle.png)


Из последнего шага можно сделать вывод что она не является завершимой (не терминируема).


***

### 2. Докозательство конечность классов эквивалентности по НФ 
1) ac  <-> c

2) aa  <-> ba

3) bc  <-> c

4) ca  <-> aa

5) cb  <-> bc

6) ccc <-> c

7) aaa <-> aa

8) aab <-> ba

9) abb <-> aba

10) bbb <-> bba


Некоторые полезные следствия, которые сразу видны из правил:

* ac <-> c и bc <-> c ⇒ буква перед $\{c}$ если это $\{a}$ или $\{b}$ может «исчезнуть» (например ac → c, bc → c). Обратная замена c → ac или c → bc тоже возможна.

* cb <-> bc вместе с bc <-> c даёт $\{cb}$ эквивалентно $\{c}$ (через cb -> bc -> c).

* ccc <-> c сокращает три подряд $\{c}$ до одного $\{c}$. Значит большие блоки $\{c}$ сокращаются по модулю 2? (не совсем, но тройки сворачиваются).

* ca <-> aa превращает $\{c}$ слева от $\{a}$ в $\{aa}$ (может как увеличивать, так и менять буквы).

* aaa <-> aa и aa <-> ba и aab <-> ba дают много тождеств между длинными блоками $\{a}$ и сочетаниями с $\{b}$: блоки $\{a}$ сворачиваются до длины ≤2 (с помощью aaa->aa), но $\{aa}$ и $\{ba}$ эквивалентны и взаимно переставляемы — т.е. $\{b}$ и $\{a}$ могут «замещать» друг друга местами.



Проведем эксперимент. 

Для всех слов длины ≤ 5 (в алфавите {a,b,c}) я построила множество слов, эквивалентных каждому слову. В этом ограниченном эксперименте получилось, что все слова длины ≤5 приводятся (в пределах поиска) к конечному набору «репрезентантов». Набор репрезентантов — следующий: a, aa, ab, ac, b, bb, bc, c, ca. 

Исходя из исходных правил и найденных представителей, можно предложить ориентированную систему переписываний (правила «в сторону нормальной формы»), которая делает попытку редуцировать каждое слово к одному из найденных репрезентантов.

Ориентированные правила:
ac  → c
bc  → c
cb  → c (через cb->bc и bc->c; записано как непосредственное редуцирование)
ccc → c
aaa → aa
aab → ba
aa  → aa  (оставляем aa фиксированной нормальной формой для «a-блоков»)
ca  → aa
abb → aba    (оставляем, если это снижает лексикографию) 
bbb → bba

Это не окончательно доказывает конечность, а лишь дает предпосылки, что система классов эквивалентности по НФ конечна. Для окончательного докозательства, рассмотрим следующий пункт. 

***

### 3. Определение локальной конфлюэнтности и пополняемость по Кнуту-Бендиксу

Для начала был выбран фундированный порядок c > a > b.

Затем упорядочены правила сначала по правилу shortlexу (равнение по длине), затем лексикографически. 

1) ac → c 

2) aa → ba 

3) bc → c 

4) ca → aa 

5) cb → bc 

6) ccc → c 

7) aaa → aa 

8) aab → ba 

9) aba → abb 

10) bba → bbb

В данном случае переписались правила 9) и 10).

Дальше приминила алгоритм пополняемость по Кнуту-Бендиксу. 

Ниже преведены примеры при которых были получины новые правила. 


(4)(1) 
\Tree [.cac [.bac [.bc c ] ] cc ] 

[(4)(1)](C:/Users/anyal/PycharmProjects/FormalLanguageTheory/Lab1/image_tree/(4)(1)tree.png)

11) cc → c



(2)(2) 
\Tree [.aaa [.baa [.bba bbb ] ] [.aba abb ] ] 

[(2)(2)](C:/Users/anyal/PycharmProjects/FormalLanguageTheory/Lab1/image_tree/(2)(2)tree.png)

12) abb → bbb



(4)(2)
\Tree [.caa [.aaa [.aa ba ] ] [.cda [.baa [.bba bbb ] ] ] ]

[(4)(2)](C:/Users/anyal/PycharmProjects/FormalLanguageTheory/Lab1/image_tree/(4)(2)tree.png)

13) bbb → ba



(7)(2)
\Tree [.aaaa [.aaa [.aa ba ] ] [.aaba [.baba [.babb [.bbbb bab ] ] ] ] ] 

[(7)(2)](C:/Users/anyal/PycharmProjects/FormalLanguageTheory/Lab1/image_tree/(7)(2)tree.png)

```
aaaa
├── aaa
│   └── aa
│       └── ba
└── aaba
    └── baba
        └── babb
            └── bbbb
                └── bab
```

14) bab → ba



(5)(10)
\Tree [.bcba [.cba [.bca [.baa [.bba [.bbb ba ] ] ] ] ] [.cbbb [.bcbb [.cbb [.bcb [.cb [.bc c ] ] ] ] ] ] ] 

[(5)(10)](C:/Users/anyal/PycharmProjects/FormalLanguageTheory/Lab1/image_tree/(5)(10)tree.png)

15) ba → c

После получения ba -> c многие критические пары уже редуцировались к одному общему нормальному виду, поэтому дальнейших новых правил уже не появлялось.

Более подробный вариант, в котором расписаны все случае представлен ниже. (фотографии ручного способа)

[Способ Кнута-Бендикса стр.1](C:/Users/anyal/PycharmProjects/FormalLanguageTheory/Lab1/image_tree/kb1.jpg)

[Способ Кнута-Бендикса стр.2](C:/Users/anyal/PycharmProjects/FormalLanguageTheory/Lab1/image_tree/kb2.jpg)

[Способ Кнута-Бендикса стр.3](C:/Users/anyal/PycharmProjects/FormalLanguageTheory/Lab1/image_tree/kb3.jpg)



Получили пять новых правил. Я просчитывала критические пары пока не переставали появляться новые правила. Далее, используя полученный набор правил для редукции слов, большинство слов сводится к небольшому множест­ву нормальных форм: a, b, c, ab, bb. 

1) ac → c 

2) aa → ba → c

3) bc → c 

4) ca → aa → ba → c

5) cb → bc → c

6) ccc → c 

7) aaa → aa → ba → c

8) aab → ba → c

9) aba → abb → bbb → ba → c

10) bba → bbb → ba → c

11) cc → c

12) abb → bbb → ba → c

13) bbb → ba → c

14) bab → ba → c

15) ba → c

Окончательная минимизированная (практическая) система правил:

aa → c

ac → c

ba → c

bc → c

cb → c

cc → c

Критические пары разрешаются, т.е. система локально конфлюэнтна. 
Отсюда вытекает и конечность классов эквовалентности. 

