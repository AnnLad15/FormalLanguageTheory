# Лабораторная работа №1 по курсу «Теория формальных языков»

Студент: Ладонцева Анна Андреевна ИУ9-52Б


### Постановка задачи
По имеющейся SRS определить:
* завершимость

* конечность классов эквивалентности по НФ (для построения эквивалент-ностей считаем, что правила могут применяться в обе стороны). Если их конечное число, то построить минимальную систему переписывания, им соответствующую.

* локальную конфлюэнтность и дополняемость по Кнуту-Бендиксу

Все проверки выше можно делать вручную. Для их фиксации желательно использовать формат та со встроенными latex-формулами, поддерживаемыми MathJax, либо формат ва обсидиана (он допускает расширенную поддержку latex в формулах). Можно и чистый latex. Допустимо сдавать и фото на листочках, но за оформление в Markdown/Latex добавляется 1 балл. Ачивка перманентная, в других лабораторных она тоже будет.

По SRS T тем самым (исключая случай, когда она сразу локально конфлюэнтна или конечна и минимальна) строится другая SRS T', которая должна сохранять те же классы эквивалентности. Если исходная SRS завершима, то правила в T' должны удовлетворять условию убывания левой части относительно правой по выбранному вами фундированному порядку

Провести автоматическое тестирование предполагаемой эквивалентности двух указанных SRS

Фазз-тестирование эквивалентности: строится случайное слово w и случайная цепочка переписываний его в w' по Т. Проверить, можно ли получить w' из w (или наоборот) в рамках правил T'.

Метаморфное тестирование: выбрать инварианты, которые должны сохраняться (либо монотонно изменяться) при переписывании в рамках T. Породить случайную цепочку переписываний над случайным словом в T' и проверить выполнимость инвариантов. Как минимум два разных инварианта. Если инвариантов найдено больше и они нетривиальные (неформально — нельзя увидеть их по SRS за пять минут внимательного рассматривания), за них можно получить до 2 дополнительных баллов.


### Индивидуальный вариант №14
1) $ac \to c$ 

2) $aa \to ba$

3) $bc \to c$

4) $ca \to aa$

5) $cb \to bc$

6) $ccc \to c$

7) $aaa \to aa$

8) $aab \to ba$

9) $abb \to aba$

10) $bbb \to bba$

***


### 1. Доказательство завершимости
У нас есть алфавит {a, b, c} и 10 правил вида u → v, где u и v — строки.
SRS завершима (terminating), если не существует бесконечной последовательности переписываний, т.е. любой процесс рано или поздно останавливается.

Сначала проверим, всегда ли длина строки уменьшается.

Длина уменьшается в правилах:

1) ac → c (2 → 1)

3) bc → c (2 → 1)

6) ccc → c (3 → 1)

7) aaa → aa (3 → 2)

8) aab → ba (3 → 2)

Длина сохраняется в правилах:

2) aa → ba (2 → 2)

4) ca → aa (2 → 2)

5) cb → bc (2 → 2)

9) abb → aba (3 → 3) 

10) bbb → bba (3 → 3)

Правил, где длина увеличивается, нету.

Теперь пройдемся более подробно по каждому правилу. 

#### Шаг 1. 

Рассмотрим правила 1) ac → c и 3) bc → c .

Из этих двух правил следует, что если перед буквой $\{c}$ встретились буква $\{a}$ или $\{b}$ , то они пропадут , а $\{c}$ останется в неизменном виде. Длинна слова уменьшается. Поэтому оба этих правила приведут к конечному результату. 

$size(t)$ > $size(t')$  (2>1)


#### Шаг 2.
Рассмотрим правила 3) bc → c и 5) cb → bc .

Правило 5) дополняет правило 3) и сново сводит его к результату $\{c}$.

$w_1$ bc $w_2$ -> $w_1$ c $w_2$

$w_1$ cb $w_2$ -> $w_1$ bc $w_2$-> $w_1$ c $w_2$


#### Шаг 3.

Рассмотрим правило 6) ccc → c.

$size(t)_c$ > $size(t')_c$  (3>1)

При получении длинной последовательности состоящей из $\{c}$, можем сократить их количество в 2/3 раза и сводит результат к $\{c}$.



#### Шаг 4.
Рассмотрим правила 1) ac → c и 4) ca → aa.

Какую бы пару не встретили всегда есть для нее правило, которое в любом случае избавляет от одной буквы ( не в значении кол-ва ).

Рассмотрим пример (построить нормальные деревья потом)




Из примера можно сделать вывод:

а) если перед $\{c}$ есть $\{a}$, то рано или поздно придем к последовательности состоящий из $\{c}$ ( в кол-ве от 1 до N штук). 

b) Если $\{a}$ стоит после $\{c}$, то все $\{c}$ превращаются в $\{a}$.



#### Шаг 5.

Рассмотрим правило 7) aaa → aa в дополнение к прошлому шагу. 

Оно уменьшает кол-во $\{a}$ и поэтому ускоряет процесс уменьшения слова. (подходит для пункта b) из шага 4)

$size(t)_a$ > $size(t')_a$  (3>2)



#### Шаг 6.

Рассмотрим оставшиеся правила, а именно:
2) aa → ba 

8) aab → ba

9) abb → aba  

10) bbb → bba 

Первые да правила сводятся к одному результату.

Вторые два правила дают разный результат, но у обоих результат зависит от первой буквы. 

Можно заметить, что у нас нет правила содержащего буквы $\{a}$ и $\{b}$, где $\{b}$ была бы первой. Здесь можно зделать пометку, что если мы дойдем до такой комбинации, то она будет конечна (не для всех случаев. Только если длина слова меньше или ровна 3)


Если рассматривать длинные слова, то к сожалению, нашлось как минимум два слова, применяя правила к которым, мы получили цикл.

[Примеры с циклом](Lab1/image_tree/tree_cucle.png)


Из последнего шага можно сделать вывод, что **она незавершима** (не терминируема).


***

### 2. Докозательство конечность классов эквивалентности по НФ 

Введем фундированный порядок shortlexу: сравнение длин, затем лексикографически c > a > b.

1) ac → c 

2) aa → ba 

3) bc → c 

4) ca → aa 

5) cb → bc 

6) ccc → c 

7) aaa → aa 

8) aab → ba 

9) aba → abb 

10) bba → bbb

В данном случае переписались правила 9) и 10).


Все слова над {a,b,c} разбиваются на ровно 6 классов эквивалентности. Представители (минимальные по shortlex) этих классов:

ε (пустая строка) — класс { ε }

a — класс {a}

b — класс {b}

ab — класс {ab}

bb — класс {bb}

c — «большой» класс, содержащий все остальные слова (включая многие слова без $\{c}$, которые через обратные применения переходят к словам с $\{c}$, и почти все слова длины ≥ 2, кроме перечисленных одиночек/пары выше).


Итого: классов ровно 6; три из них — одноэлементные (ε,a,b), ещё два — состоящие из двух элементов (ab, bb), и один огромный класс с представителем $\{c}$.


Почему ε, a, b, ab, bb — отдельные классы
* Пустая строка ε:  ни одно правило (ни LHS, ни RHS) нельзя применить к ε ни в одну сторону. Следовательно ε не связана ни с каким другим словом.

* a и b: ни одна LHS не равна $\{a}$ или $\{b}$ (все LHS имеют длину ≥2), поэтому из $\{a}$ / $\{b}$ нельзя сделать другое слово «вперёд». Чтобы получить $\{a}$ или $\{b}$ из другого слова обратной заменой нужно, чтобы какое-то RHS равно $\{a}$ / $\{b}$ — таких RHS нет. Следовательно $\{a}$ и $\{b}$ не связаны с другими словами.


* ab и bb: проверка по образцам: ни одна LHS ≠ $\{ab}$ / $\{bb}$, и в $\{ab}$ / $\{bb}$ нет ни одной RHS-подстроки (например ba, aa, abb, bbb, c и т.д.), поэтому ни прямых, ни обратных применений нет. Также никакие другие слова без $\{c}$ сокращаются до $\{ab}$ или $\{bb}$ (нет RHS = $\{ab}$ / $\{bb}$). Итог: $\{ab}$ и $\{bb}$ изолированы.



Почему «всё остальное» лежит в одном классе с $\{c}$
При построении связей (разрешая применять правила в обе стороны) видна следующая картина: многие слова (особенно те, которые содержат $\{c}$, или имеют достаточную длину и содержащие LHS-подстроки) связаны между собой цепочками замен, и все они попадают в один большой компонент графа преобразований, который содержит $\{c}$.

Примеры конкретных цепочек (показывает связь с $\{c}$):

abac → (1) → abc → (3) → ac → (1) → c.

bbac → (1) → bbc → (3) → bc → (3) → c.

ccc → (6) → c.

cab → (4) → aab → (8) → ba — показывает, что некоторые слова с $\{c}$ переходят в класс без $\{c}$ (в частности $\{ba}$), но затем из $\{ba}$ обратными правилами/цепочками можно вернуться в класс с $\{c}$ (через появления bbb → bba ↔ и т.д.), поэтому все эти слова оказываются в общем большом компоненте, представителем которого удобно взять $\{c}$. Продление этой цепочки: ba → (2) → aa → (4) → ca → (3) → bca → (3) → bbca → (5) → bcba → (5) → cbba → (10) → cbbb → (5) → bcbb → (3) → cbb → (5) → bcb → (3) → cb → (5) → bc → (3) → c.


***

### 3. Определение локальной конфлюэнтности и пополняемость по Кнуту-Бендиксу
Используем систему правил из пункта 2.

Применим алгоритм пополняемость по Кнуту-Бендиксу. 

Ниже преведены примеры при которых были получины новые правила. 

[(4)(1)](Lab1/image_tree/(4)(1)tree.png)

11) cc → c


[(2)(2)](Lab1/image_tree/(2)(2)tree.png)

12) abb → bbb


[(4)(2)](Lab1/image_tree/(4)(2)tree.png)

13) bbb → ba


[(7)(2)](Lab1/image_tree/(7)(2)tree.png)

14) bab → ba


[(5)(10)](Lab1/image_tree/(5)(10)tree.png)

15) ba → c

После получения ba -> c многие критические пары уже редуцировались к одному общему нормальному виду, поэтому дальнейших новых правил уже не появлялось.

Более подробный вариант, в котором расписаны все случаи, представлен ниже. (фотографии ручного способа)

[Способ Кнута-Бендикса стр.1](Lab1/image_tree/kb1.jpg)

[Способ Кнута-Бендикса стр.2](Lab1/image_tree/kb2.jpg)

[Способ Кнута-Бендикса стр.3](Lab1/image_tree/kb3.jpg)



Получили пять новых правил. Я просчитывала критические пары пока не переставали появляться новые правила. Далее, используя полученный набор правил для редукции слов, большинство слов сводится к небольшому множест­ву нормальных форм: a, b, c, ab, bb. 

1) ac → c 

2) aa → ba → c

3) bc → c 

4) ca → aa → ba → c

5) cb → bc → c

6) ccc → c 

7) aaa → aa → ba → c

8) aab → ba → c

9) aba → abb → bbb → ba → c

10) bba → bbb → ba → c

11) cc → c

12) abb → bbb → ba → c

13) bbb → ba → c

14) bab → ba → c

15) ba → c

Окончательная минимизированная (практическая) система правил:

aa → c

ac → c

ba → c

bc → c

cb → c

cc → c

**Вывод: процедура Кнута–Бендикса завершится конечным набором правил. Критические пары разрешаются, т.е. система локально конфлюэнтна.**


### 4. Фазз-тестирование эквивалентности
Представлено кодом в файлах fuzztest.py, srs.py, test_rules.py


### 5. Метаморфное тестирование 
Представлено кодом в файле invariants.py

Инварианты:
1) 
2) 
